name: Deploy to WSL2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: self-hosted  # Runs on your WSL2 runner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to WSL2
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          RAWG_API_KEY: ${{ secrets.RAWG_API_KEY }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          APP_PORT: ${{ secrets.APP_PORT }}
        run: |
          set -e
          
          echo "üöÄ Starting deployment to WSL2..."
          
          # Navigate to WSL2 deployment directory
          cd ~/apps/cartridge
          
          echo "üì¶ Pulling latest changes..."
          git pull origin main
          
          echo "üîß Creating .env file from GitHub secrets..."
          echo "STEAM_API_KEY=${STEAM_API_KEY}" > .env
          echo "RAWG_API_KEY=${RAWG_API_KEY}" >> .env
          echo "POSTGRES_USER=${POSTGRES_USER}" >> .env
          echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}" >> .env
          echo "POSTGRES_DB=${POSTGRES_DB}" >> .env
          echo "POSTGRES_PORT=${POSTGRES_PORT}" >> .env
          echo "ASPNETCORE_ENVIRONMENT=Production" >> .env
          echo "APP_PORT=${APP_PORT}" >> .env
          
          echo "ÔøΩÔ∏è Ensuring PostgreSQL service is up..."
          # Always start / ensure postgres running first (won't recreate volume unless removed)
          docker compose up -d postgres

          echo "‚è≥ Waiting for Postgres health..."
          # Wait for healthcheck (compose v2 has 'wait', fallback to sleep if unavailable)
          if docker compose wait postgres 2>/dev/null; then
            echo "‚úÖ Postgres healthy"
          else
            # Fallback simple loop
            for i in {1..10}; do
              if docker compose ps --format json | grep -q '"Service":"postgres"'; then
                if docker compose exec -T postgres pg_isready -U ${POSTGRES_USER} >/dev/null 2>&1 || docker compose exec -T postgres pg_isready -U postgres >/dev/null 2>&1; then
                  echo "‚úÖ Postgres accepting connections"
                  break
                fi
              fi
              echo "‚è≥ Waiting for Postgres (${i}/10)..."
              sleep 3
            done
          fi

          echo "ÔøΩ Synchronizing database role & password..."
          # Use postgres superuser fallback to manage role. If custom user doesn't exist, create it.
          # This block is idempotent: will create or update role each deploy.
          docker compose exec -T postgres psql -U postgres <<'SQL'
DO $$
DECLARE
  target_role TEXT := '${POSTGRES_USER}';
  new_password TEXT := '${POSTGRES_PASSWORD}';
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = target_role) THEN
    RAISE NOTICE 'Creating role %', target_role;
    EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', target_role, new_password);
  ELSE
    RAISE NOTICE 'Altering password for role %', target_role;
    EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', target_role, new_password);
  END IF;
END$$;
SQL

          echo "üß™ Verifying role connectivity with updated password..."
          if docker compose exec -T postgres psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT 1" >/dev/null 2>&1; then
            echo "‚úÖ Role password verification succeeded"
          else
            echo "‚ùå Failed to verify role password (this should not happen). Dumping roles:"
            docker compose exec -T postgres psql -U postgres -c "\du" || true
            exit 1
          fi

          echo "ÔøΩ Rebuilding and updating web service..."
          docker compose up -d --build web

          echo "üßπ Removing dangling images..."
          docker image prune -f || true
          
          echo "‚è≥ Waiting for health check..."
          sleep 10
          
          echo "‚úÖ Checking container status..."
          docker compose ps
          
          echo "üìä Deployment completed successfully!"
      
      - name: Health Check
        env:
          HEALTH_CHECK_URL: ${{ secrets.HEALTH_CHECK_URL }}
        run: |
          echo "üîç Running health check..."
          sleep 15
          
          if [ -n "$HEALTH_CHECK_URL" ]; then
            # Try up to 5 times with 10 second delays
            for i in {1..5}; do
              if curl -f -s -o /dev/null "$HEALTH_CHECK_URL"; then
                echo "‚úÖ Health check passed! Application is responding."
                exit 0
              else
                echo "‚è≥ Attempt $i/5 failed, waiting 10 seconds..."
                sleep 10
              fi
            done
            echo "‚ùå Health check failed after 5 attempts"
            exit 1
          else
            echo "‚ö†Ô∏è HEALTH_CHECK_URL not set, skipping health check"
            echo "   Set this secret to enable health checks (e.g., https://cartridge.step0fail.com)"
          fi
      
      - name: Cleanup Old Docker Images
        run: |
          cd ~/apps/cartridge
          echo "üßπ Cleaning up old Docker images..."
          docker image prune -f
          echo "‚úÖ Cleanup completed"
      
      - name: Send Deployment Notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "üéâ Deployment succeeded!"
          else
            echo "‚ùå Deployment failed!"
          fi
