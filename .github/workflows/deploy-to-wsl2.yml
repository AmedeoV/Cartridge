name: Deploy to WSL2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: self-hosted  # Runs on your WSL2 runner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to WSL2
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          RAWG_API_KEY: ${{ secrets.RAWG_API_KEY }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          APP_PORT: ${{ secrets.APP_PORT }}
        run: |
          set -euo pipefail

          echo "Starting deployment to WSL2..."

          cd ~/apps/cartridge
          echo "Pulling latest changes..."
          git pull origin main

          echo "Writing .env file..."
          {
            echo "STEAM_API_KEY=${STEAM_API_KEY}"
            echo "RAWG_API_KEY=${RAWG_API_KEY}"
            echo "POSTGRES_USER=${POSTGRES_USER}"
            echo "POSTGRES_PASSWORD=${POSTGRES_PASSWORD}"
            echo "POSTGRES_DB=${POSTGRES_DB}"
            echo "POSTGRES_PORT=${POSTGRES_PORT}"
            echo "ASPNETCORE_ENVIRONMENT=Production"
            echo "APP_PORT=${APP_PORT}"
          } > .env

          echo "Ensuring postgres service is up..."
          docker compose up -d postgres

          echo "Waiting for postgres readiness..."
          if docker compose wait postgres 2>/dev/null; then
            echo "Postgres healthy"
          else
            for i in {1..10}; do
              if docker compose exec -T postgres pg_isready -U "${POSTGRES_USER}" >/dev/null 2>&1 || \
                 docker compose exec -T postgres pg_isready -U postgres >/dev/null 2>&1; then
                echo "Postgres accepting connections"
                break
              fi
              echo "Retry $i/10..."
              sleep 3
            done
          fi

          echo "Synchronizing database role & password..."
          
          SQL_COMMAND="
          DO \$\$
          DECLARE
            target_role TEXT := '${POSTGRES_USER}';
            new_password TEXT := '${POSTGRES_PASSWORD}';
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = target_role) THEN
              RAISE NOTICE 'Creating role %', target_role;
              EXECUTE format('CREATE ROLE %I LOGIN PASSWORD %L', target_role, new_password);
            ELSE
              RAISE NOTICE 'Altering password for role %', target_role;
              EXECUTE format('ALTER ROLE %I WITH PASSWORD %L', target_role, new_password);
            END IF;
          END
          \$\$;
          "
          docker compose exec -T postgres psql -U postgres -c "$SQL_COMMAND"

          echo "Verifying role connectivity..."
          if docker compose exec -T postgres psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -c "SELECT 1" >/dev/null 2>&1; then
            echo "Role password OK"
          else
            echo "Role verification failed; dumping roles"
            docker compose exec -T postgres psql -U postgres -c "\du" || true
            exit 1
          fi

          echo "Rebuilding web service..."
          docker compose up -d --build web

          echo "Pruning dangling images..."
          docker image prune -f || true

          echo "Waiting before status check..."
          sleep 10

          echo "Container status:"
          docker compose ps

          echo "Deployment completed"
      
      - name: Health Check
        env:
          HEALTH_CHECK_URL: ${{ secrets.HEALTH_CHECK_URL }}
        run: |
          echo "üîç Running health check..."
          sleep 15
          
          if [ -n "$HEALTH_CHECK_URL" ]; then
            # Try up to 5 times with 10 second delays
            for i in {1..5}; do
              if curl -f -s -o /dev/null "$HEALTH_CHECK_URL"; then
                echo "‚úÖ Health check passed! Application is responding."
                exit 0
              else
                echo "‚è≥ Attempt $i/5 failed, waiting 10 seconds..."
                sleep 10
              fi
            done
            echo "‚ùå Health check failed after 5 attempts"
            exit 1
          else
            echo "‚ö†Ô∏è HEALTH_CHECK_URL not set, skipping health check"
            echo "   Set this secret to enable health checks (e.g., https://cartridge.step0fail.com)"
          fi
      
      - name: Cleanup Old Docker Images
        run: |
          cd ~/apps/cartridge
          echo "üßπ Cleaning up old Docker images..."
          docker image prune -f
          echo "‚úÖ Cleanup completed"
      
      - name: Send Deployment Notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "üéâ Deployment succeeded!"
          else
            echo "‚ùå Deployment failed!"
          fi
