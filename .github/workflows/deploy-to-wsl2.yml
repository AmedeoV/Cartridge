name: Deploy to WSL2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: self-hosted  # Runs on your WSL2 runner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to WSL2
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          RAWG_API_KEY: ${{ secrets.RAWG_API_KEY }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          APP_PORT: ${{ secrets.APP_PORT }}
        run: |
          set -e
          
          echo "ðŸš€ Starting deployment to WSL2..."
          
          # Navigate to WSL2 deployment directory
          cd ~/apps/cartridge
          
          echo "ðŸ“¦ Pulling latest changes..."
          git pull origin main
          
          echo "ðŸ”§ Creating .env file from GitHub secrets..."
          cat > .env <<EOF
          # =============================================================================
          # API KEYS
          # =============================================================================
          STEAM_API_KEY=${STEAM_API_KEY}
          RAWG_API_KEY=${RAWG_API_KEY}
          
          # =============================================================================
          # DATABASE CONFIGURATION
          # =============================================================================
          POSTGRES_USER=${POSTGRES_USER}
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          POSTGRES_DB=${POSTGRES_DB}
          POSTGRES_PORT=${POSTGRES_PORT}
          
          # =============================================================================
          # APPLICATION CONFIGURATION
          # =============================================================================
          ASPNETCORE_ENVIRONMENT=Production
          APP_PORT=${APP_PORT}
          EOF
          
          echo "ï¿½ Performing rolling update (zero-downtime)..."
          docker compose build web
          
          echo "ðŸš€ Starting new web container..."
          docker compose up -d --no-deps --build --wait web
          
          echo "â³ Waiting for health check..."
          sleep 10
          
          echo "âœ… Checking container status..."
          docker compose ps
          
          echo "ðŸ“Š Deployment completed successfully!"
      
      - name: Health Check
        env:
          HEALTH_CHECK_URL: ${{ secrets.HEALTH_CHECK_URL }}
        run: |
          echo "ðŸ” Running health check..."
          sleep 15
          
          if [ -n "$HEALTH_CHECK_URL" ]; then
            # Try up to 5 times with 10 second delays
            for i in {1..5}; do
              if curl -f -s -o /dev/null "$HEALTH_CHECK_URL"; then
                echo "âœ… Health check passed! Application is responding."
                exit 0
              else
                echo "â³ Attempt $i/5 failed, waiting 10 seconds..."
                sleep 10
              fi
            done
            echo "âŒ Health check failed after 5 attempts"
            exit 1
          else
            echo "âš ï¸ HEALTH_CHECK_URL not set, skipping health check"
            echo "   Set this secret to enable health checks (e.g., https://cartridge.step0fail.com)"
          fi
      
      - name: Cleanup Old Docker Images
        run: |
          cd ~/apps/cartridge
          echo "ðŸ§¹ Cleaning up old Docker images..."
          docker image prune -f
          echo "âœ… Cleanup completed"
      
      - name: Send Deployment Notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "ðŸŽ‰ Deployment succeeded!"
          else
            echo "âŒ Deployment failed!"
          fi
