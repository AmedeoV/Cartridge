name: Deploy to WSL2

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: self-hosted  # Runs on your WSL2 runner
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to WSL2
        env:
          STEAM_API_KEY: ${{ secrets.STEAM_API_KEY }}
          RAWG_API_KEY: ${{ secrets.RAWG_API_KEY }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          APP_PORT: ${{ secrets.APP_PORT }}
        run: |
          set -e
          
          echo "ğŸš€ Starting deployment to WSL2..."
          
          # Navigate to WSL2 deployment directory
          cd ~/apps/cartridge
          
          echo "ğŸ“¦ Pulling latest changes..."
          git pull origin main
          
          echo "ğŸ”§ Creating .env file from GitHub secrets..."
          cat > .env << 'ENVFILE'
# =============================================================================
# API KEYS
# =============================================================================
STEAM_API_KEY=PLACEHOLDER_STEAM_API_KEY
RAWG_API_KEY=PLACEHOLDER_RAWG_API_KEY
# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================
POSTGRES_USER=PLACEHOLDER_POSTGRES_USER
POSTGRES_PASSWORD=PLACEHOLDER_POSTGRES_PASSWORD
POSTGRES_DB=PLACEHOLDER_POSTGRES_DB
POSTGRES_PORT=PLACEHOLDER_POSTGRES_PORT
# =============================================================================
# APPLICATION CONFIGURATION
# =============================================================================
ASPNETCORE_ENVIRONMENT=Production
APP_PORT=PLACEHOLDER_APP_PORT
ENVFILE
          
          # Replace placeholders with actual values using perl for better handling
          perl -i -pe "s|PLACEHOLDER_STEAM_API_KEY|$ENV{STEAM_API_KEY}|g" .env
          perl -i -pe "s|PLACEHOLDER_RAWG_API_KEY|$ENV{RAWG_API_KEY}|g" .env
          perl -i -pe "s|PLACEHOLDER_POSTGRES_USER|$ENV{POSTGRES_USER}|g" .env
          perl -i -pe "s|PLACEHOLDER_POSTGRES_PASSWORD|$ENV{POSTGRES_PASSWORD}|g" .env
          perl -i -pe "s|PLACEHOLDER_POSTGRES_DB|$ENV{POSTGRES_DB}|g" .env
          perl -i -pe "s|PLACEHOLDER_POSTGRES_PORT|$ENV{POSTGRES_PORT}|g" .env
          perl -i -pe "s|PLACEHOLDER_APP_PORT|$ENV{APP_PORT}|g" .env
          
          echo "ğŸ” Checking if database needs to be recreated..."
          # Check if postgres container exists and if password has changed
          if docker compose ps postgres | grep -q "Up"; then
            echo "ğŸ“Š Database container is running, checking password..."
            if docker compose exec -T postgres psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c "SELECT 1" > /dev/null 2>&1; then
              echo "âœ… Database credentials are valid"
              DB_NEEDS_RESTART=false
            else
              echo "âš ï¸  Database password has changed, full restart required"
              DB_NEEDS_RESTART=true
            fi
          else
            echo "ğŸ“Š Database container not running"
            DB_NEEDS_RESTART=true
          fi
          
          if [ "$DB_NEEDS_RESTART" = true ]; then
            echo "ğŸ›‘ Performing full restart (database credentials changed)..."
            docker compose down
            docker compose up -d --build
          else
            echo "ğŸ”„ Performing rolling update (zero-downtime)..."
            docker compose build web
            
            echo "ğŸš€ Starting new web container..."
            docker compose up -d --no-deps --build --wait web
          fi
          
          echo "â³ Waiting for health check..."
          sleep 10
          
          echo "âœ… Checking container status..."
          docker compose ps
          
          echo "ğŸ“Š Deployment completed successfully!"
      
      - name: Health Check
        env:
          HEALTH_CHECK_URL: ${{ secrets.HEALTH_CHECK_URL }}
        run: |
          echo "ğŸ” Running health check..."
          sleep 15
          
          if [ -n "$HEALTH_CHECK_URL" ]; then
            # Try up to 5 times with 10 second delays
            for i in {1..5}; do
              if curl -f -s -o /dev/null "$HEALTH_CHECK_URL"; then
                echo "âœ… Health check passed! Application is responding."
                exit 0
              else
                echo "â³ Attempt $i/5 failed, waiting 10 seconds..."
                sleep 10
              fi
            done
            echo "âŒ Health check failed after 5 attempts"
            exit 1
          else
            echo "âš ï¸ HEALTH_CHECK_URL not set, skipping health check"
            echo "   Set this secret to enable health checks (e.g., https://cartridge.step0fail.com)"
          fi
      
      - name: Cleanup Old Docker Images
        run: |
          cd ~/apps/cartridge
          echo "ğŸ§¹ Cleaning up old Docker images..."
          docker image prune -f
          echo "âœ… Cleanup completed"
      
      - name: Send Deployment Notification
        if: always()
        run: |
          if [ ${{ job.status }} == 'success' ]; then
            echo "ğŸ‰ Deployment succeeded!"
          else
            echo "âŒ Deployment failed!"
          fi
